- [cqplus](#cqplus)
  - [Run and build documentation](#run-and-build-documentation)
  - [Run an example](#run-an-example)
  - [Contents](#contents)
  - [Some modifications to the paper](#some-modifications-to-the-paper)
  - [TODOs](#todos)

# cqplus
## Run and build documentation
- To build the library, run `make` or run `cargo build`
- To build the documentation (with latex supported), run `make d` or run `RUSTDOCFLAGS="--html-in-header katex-header.html" cargo doc --no-deps --open`

## Run an example
- To run an example, first clone this repository and clone a testcq repository (in a same folder), then go to testcq directory and run `cargo run`
```bash
git clone https://github.com/HuyHung0/cqplus.git
git clone https://github.com/HuyHung0/testcq.git
cd testcq
cargo run
```
We can put two repository in different place, but make sure to add the path of the library `cqplus` in the `Cargo.toml` file of `testcq`

## Contents
- The notation of functions and variables in this project are based on the notation of the figure 1, page 19 of the paper in [https://eprint.iacr.org/2023/1518](https://eprint.iacr.org/2023/1518).
  - The formulas of each calculated polynomial are written in comments before the function
- Some functions was implemented in this repository [https://github.com/geometryresearch/cq](https://github.com/geometryresearch/cq)
  - create srs (which is in `utils.rs` of the `cq` repository)
  - create table (which is in `table.rs` of the `cq` repository)
  - create commitments of polynomial (which is in `kzg.rs` of the `cq` repository)
  - For the rest, I implemented from beginning
- The structures of the codes as follows:
  - First is `srs.rs` and `table.rs` to create Srs and table structure
  - `polynomials.rs` contains some basic polynomials for computation such as Lagrange basic, vanishing polynomial on a set,...
  - `kzg.rs` contains function to compute the commitment to a polynomial
  - After that
    - `derive.rs`: implement the `derive` function
    - `prover.rs`: implement the `prove` function
    - `verifier.rs`: implement the `verify` function
    - `data_structures.rs` contains the structures of the return of function `derive()` and `prove()`

## Some modifications to the paper
- In `derive()` function,
  - there is a typo in the formula of $T(X)$.
  - when compute the commitment of $\nu_K(s)U(s)$ in $G_2$, we need a condition about the degree of this polynomial and the length of srs in $G_2$. More specific, we need $(N-1)+(N_1-N+2) < N_2$ ,i.e., we need $N_1+2 \geq N_2$
- In `prove()` function,
  - Need to modify the input
    - when compute $[B(s)]_1$, we need to evaluation $\rho_B(X)$ at $s$. Hence, the secret `s` should be in the input
    - the input notation $e{N,n}$ should be the same as the output $e_{t,n}$ of `derive()` function
- In `verify()` function:
  - It written that computing $[D(s)]_1$, however, we don't know the components. I guess that this should be computed in `prove()` function and the result should added to the return of `prove()`
  - We need $[U(X)]_2$. Hence, I guess that It should also include in the return of `derive()`.
  - The same for $c_t$. We need $[c_t]_2$ but in `derive()`, we only have $[c_t]_1$
  - The same for $[B_\gamma]_1$, $[X-\gamma]_2$
  - We also need some randoms value generated by `prove()` such as $\beta,\gamma,\eta$. Hence, it should include in the return of the `prove()`
  - In the end of condition i, it wrote $[x]_2$. I guess it should be $[1]_2$.

## TODOs
- Remove some debug commands in the library
- Update the crate version in `Cargo.toml` (in the new version, the some function names are changed, some functions are removed)
- Implement the hash function which depends on all public inputs.
- If the project is corrected, public to crates.io



